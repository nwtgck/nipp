/* Generated by Opal 0.11.0 */
Opal.modules["thread"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$allocate', '$core_initialize!', '$current', '$fail', '$[]', '$coerce_key_name', '$[]=', '$-', '$key?', '$keys', '$private', '$coerce_to!', '$public', '$clear', '$empty?', '$size', '$shift', '$push', '$each', '$to_proc', '$locked?', '$lock', '$unlock']);
  
  (function($base, $super, $parent_nesting) {
    function $ThreadError(){};
    var self = $ThreadError = $klass($base, $super, 'ThreadError', $ThreadError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $Thread(){};
    var self = $Thread = $klass($base, $super, 'Thread', $Thread);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Thread_current_1, TMP_Thread_list_2, TMP_Thread_initialize_3, TMP_Thread_$$_4, TMP_Thread_$$$eq_5, TMP_Thread_key$q_6, TMP_Thread_keys_7, TMP_Thread_thread_variable_get_8, TMP_Thread_thread_variable_set_9, TMP_Thread_thread_variable$q_10, TMP_Thread_thread_variables_11, TMP_Thread_core_initialize$B_12, TMP_Thread_coerce_key_name_13;

    def.fiber_locals = def.thread_locals = nil;
    
    Opal.defs(self, '$current', TMP_Thread_current_1 = function $$current() {
      var self = this;
      if (self.current == null) self.current = nil;

      
      if ($truthy(self.current)) {
        } else {
        
        self.current = self.$allocate();
        self.current['$core_initialize!']();
      };
      return self.current;
    }, TMP_Thread_current_1.$$arity = 0);
    Opal.defs(self, '$list', TMP_Thread_list_2 = function $$list() {
      var self = this;

      return [self.$current()]
    }, TMP_Thread_list_2.$$arity = 0);
    
    Opal.defn(self, '$initialize', TMP_Thread_initialize_3 = function $$initialize($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return self.$fail(Opal.const_get_relative($nesting, 'NotImplementedError'), "Thread creation not available")
    }, TMP_Thread_initialize_3.$$arity = -1);
    
    Opal.defn(self, '$[]', TMP_Thread_$$_4 = function(key) {
      var self = this;

      return self.fiber_locals['$[]'](self.$coerce_key_name(key))
    }, TMP_Thread_$$_4.$$arity = 1);
    
    Opal.defn(self, '$[]=', TMP_Thread_$$$eq_5 = function(key, value) {
      var self = this, $writer = nil;

      
      $writer = [self.$coerce_key_name(key), value];
      $send(self.fiber_locals, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];
    }, TMP_Thread_$$$eq_5.$$arity = 2);
    
    Opal.defn(self, '$key?', TMP_Thread_key$q_6 = function(key) {
      var self = this;

      return self.fiber_locals['$key?'](self.$coerce_key_name(key))
    }, TMP_Thread_key$q_6.$$arity = 1);
    
    Opal.defn(self, '$keys', TMP_Thread_keys_7 = function $$keys() {
      var self = this;

      return self.fiber_locals.$keys()
    }, TMP_Thread_keys_7.$$arity = 0);
    
    Opal.defn(self, '$thread_variable_get', TMP_Thread_thread_variable_get_8 = function $$thread_variable_get(key) {
      var self = this;

      return self.thread_locals['$[]'](self.$coerce_key_name(key))
    }, TMP_Thread_thread_variable_get_8.$$arity = 1);
    
    Opal.defn(self, '$thread_variable_set', TMP_Thread_thread_variable_set_9 = function $$thread_variable_set(key, value) {
      var self = this, $writer = nil;

      
      $writer = [self.$coerce_key_name(key), value];
      $send(self.thread_locals, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];
    }, TMP_Thread_thread_variable_set_9.$$arity = 2);
    
    Opal.defn(self, '$thread_variable?', TMP_Thread_thread_variable$q_10 = function(key) {
      var self = this;

      return self.thread_locals['$key?'](self.$coerce_key_name(key))
    }, TMP_Thread_thread_variable$q_10.$$arity = 1);
    
    Opal.defn(self, '$thread_variables', TMP_Thread_thread_variables_11 = function $$thread_variables() {
      var self = this;

      return self.thread_locals.$keys()
    }, TMP_Thread_thread_variables_11.$$arity = 0);
    self.$private();
    
    Opal.defn(self, '$core_initialize!', TMP_Thread_core_initialize$B_12 = function() {
      var self = this;

      
      self.thread_locals = $hash2([], {});
      return (self.fiber_locals = $hash2([], {}));
    }, TMP_Thread_core_initialize$B_12.$$arity = 0);
    
    Opal.defn(self, '$coerce_key_name', TMP_Thread_coerce_key_name_13 = function $$coerce_key_name(key) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](key, Opal.const_get_relative($nesting, 'String'), "to_s")
    }, TMP_Thread_coerce_key_name_13.$$arity = 1);
    self.$public();
    return (function($base, $super, $parent_nesting) {
      function $Queue(){};
      var self = $Queue = $klass($base, $super, 'Queue', $Queue);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Queue_initialize_14, TMP_Queue_clear_15, TMP_Queue_empty$q_16, TMP_Queue_size_17, TMP_Queue_pop_18, TMP_Queue_push_19, TMP_Queue_each_20;

      def.storage = nil;
      
      
      Opal.defn(self, '$initialize', TMP_Queue_initialize_14 = function $$initialize() {
        var self = this;

        return self.$clear()
      }, TMP_Queue_initialize_14.$$arity = 0);
      
      Opal.defn(self, '$clear', TMP_Queue_clear_15 = function $$clear() {
        var self = this;

        return (self.storage = [])
      }, TMP_Queue_clear_15.$$arity = 0);
      
      Opal.defn(self, '$empty?', TMP_Queue_empty$q_16 = function() {
        var self = this;

        return self.storage['$empty?']()
      }, TMP_Queue_empty$q_16.$$arity = 0);
      
      Opal.defn(self, '$size', TMP_Queue_size_17 = function $$size() {
        var self = this;

        return self.storage.$size()
      }, TMP_Queue_size_17.$$arity = 0);
      Opal.alias(self, "length", "size");
      
      Opal.defn(self, '$pop', TMP_Queue_pop_18 = function $$pop(non_block) {
        var self = this;

        if (non_block == null) {
          non_block = false;
        }
        
        if ($truthy(self['$empty?']())) {
          
          if ($truthy(non_block)) {
            self.$fail(Opal.const_get_relative($nesting, 'ThreadError'), "Queue empty")};
          self.$fail(Opal.const_get_relative($nesting, 'ThreadError'), "Deadlock");};
        return self.storage.$shift();
      }, TMP_Queue_pop_18.$$arity = -1);
      Opal.alias(self, "shift", "pop");
      Opal.alias(self, "deq", "pop");
      
      Opal.defn(self, '$push', TMP_Queue_push_19 = function $$push(value) {
        var self = this;

        return self.storage.$push(value)
      }, TMP_Queue_push_19.$$arity = 1);
      Opal.alias(self, "<<", "push");
      Opal.alias(self, "enq", "push");
      return (Opal.defn(self, '$each', TMP_Queue_each_20 = function $$each() {
        var self = this, $iter = TMP_Queue_each_20.$$p, block = $iter || nil;

        if ($iter) TMP_Queue_each_20.$$p = null;
        return $send(self.storage, 'each', [], block.$to_proc())
      }, TMP_Queue_each_20.$$arity = 0), nil) && 'each';
    })($nesting[0], null, $nesting);
  })($nesting[0], null, $nesting);
  Opal.const_set($nesting[0], 'Queue', Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Thread'), 'Queue'));
  return (function($base, $super, $parent_nesting) {
    function $Mutex(){};
    var self = $Mutex = $klass($base, $super, 'Mutex', $Mutex);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Mutex_initialize_21, TMP_Mutex_lock_22, TMP_Mutex_locked$q_23, TMP_Mutex_owned$q_24, TMP_Mutex_try_lock_25, TMP_Mutex_unlock_26, TMP_Mutex_synchronize_27;

    def.locked = nil;
    
    
    Opal.defn(self, '$initialize', TMP_Mutex_initialize_21 = function $$initialize() {
      var self = this;

      return (self.locked = false)
    }, TMP_Mutex_initialize_21.$$arity = 0);
    
    Opal.defn(self, '$lock', TMP_Mutex_lock_22 = function $$lock() {
      var self = this;

      
      if ($truthy(self.locked)) {
        self.$fail(Opal.const_get_relative($nesting, 'ThreadError'), "Deadlock")};
      self.locked = true;
      return self;
    }, TMP_Mutex_lock_22.$$arity = 0);
    
    Opal.defn(self, '$locked?', TMP_Mutex_locked$q_23 = function() {
      var self = this;

      return self.locked
    }, TMP_Mutex_locked$q_23.$$arity = 0);
    
    Opal.defn(self, '$owned?', TMP_Mutex_owned$q_24 = function() {
      var self = this;

      return self.locked
    }, TMP_Mutex_owned$q_24.$$arity = 0);
    
    Opal.defn(self, '$try_lock', TMP_Mutex_try_lock_25 = function $$try_lock() {
      var self = this;

      if ($truthy(self['$locked?']())) {
        return false
        } else {
        
        self.$lock();
        return true;
      }
    }, TMP_Mutex_try_lock_25.$$arity = 0);
    
    Opal.defn(self, '$unlock', TMP_Mutex_unlock_26 = function $$unlock() {
      var self = this;

      
      if ($truthy(self.locked)) {
        } else {
        self.$fail(Opal.const_get_relative($nesting, 'ThreadError'), "Mutex not locked")
      };
      self.locked = false;
      return self;
    }, TMP_Mutex_unlock_26.$$arity = 0);
    return (Opal.defn(self, '$synchronize', TMP_Mutex_synchronize_27 = function $$synchronize() {
      var self = this, $iter = TMP_Mutex_synchronize_27.$$p, $yield = $iter || nil;

      if ($iter) TMP_Mutex_synchronize_27.$$p = null;
      
      self.$lock();
      
      return (function() { try {
      return Opal.yieldX($yield, []);
      } finally {
        self.$unlock()
      }; })();;
    }, TMP_Mutex_synchronize_27.$$arity = 0), nil) && 'synchronize';
  })($nesting[0], null, $nesting);
};
